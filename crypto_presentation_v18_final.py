# -*- coding: utf-8 -*-
"""Crypto Presentation V18

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1Ta6AV0rdWbRlWCt4WTRZUtSRozvBVxuN
"""

import streamlit as st
import pandas as pd
import numpy as np
import plotly.graph_objects as go
import plotly.express as px
import time
from datetime import datetime
import random

# -----------------------------------------------------------------------------
# 1. æ ¸å¿ƒç³»ç»Ÿé…ç½® (CYBERPUNK UI - ULTRA)
# -----------------------------------------------------------------------------
st.set_page_config(
    page_title="Cryptocurrency Prediction",
    page_icon="ğŸ“ˆ",
    layout="wide",
    initial_sidebar_state="expanded"
)

# æ³¨å…¥ç»ˆæç¾åŒ– CSS
st.markdown("""
<style>
    /* å¼•å…¥ç§‘å¹»å­—ä½“ */
    @import url('https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&family=Roboto+Mono:wght@400;700&display=swap');

    /* å…¨å±€èƒŒæ™¯ï¼šæ·±ç©ºå¾„å‘æ¸å˜ */
    .stApp {
        background-color: #050505;
        background-image: radial-gradient(circle at 50% 50%, #0a0a0a 0%, #000000 100%);
    }

    /* éœ“è™¹æ ‡é¢˜ç‰¹æ•ˆ */
    h1, h2, h3 {
        font-family: 'Orbitron', sans-serif !important;
        color: #00ffcc !important;
        text-shadow: 0 0 10px rgba(0, 255, 204, 0.5), 0 0 20px rgba(0, 255, 204, 0.3);
        letter-spacing: 1px;
    }

    /* é¡¶éƒ¨çŠ¶æ€æ  - ç»ç’ƒæ‹Ÿæ€ */
    .status-bar {
        display: flex; justify-content: space-between; padding: 12px 25px;
        background: rgba(10, 10, 10, 0.7);
        backdrop-filter: blur(10px);
        border-bottom: 1px solid #00ffcc;
        border-top: 1px solid rgba(0, 255, 204, 0.3);
        color: #aaa; font-family: 'Roboto Mono', monospace; margin-bottom: 25px;
        box-shadow: 0 0 20px rgba(0, 255, 204, 0.1);
        border-radius: 5px;
    }
    .status-value {
        color: #00ffcc;
        font-weight: bold;
        text-shadow: 0 0 5px #00ffcc;
    }

    /* æŒ‡æ ‡å¡ç‰‡ - é«˜ç§‘æŠ€è¾¹æ¡† */
    div[data-testid="stMetric"] {
        background-color: rgba(14, 14, 14, 0.8);
        border: 1px solid #333;
        border-left: 4px solid #00ffcc;
        padding: 15px;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0,0,0,0.5);
        transition: all 0.3s ease;
    }
    div[data-testid="stMetric"]:hover {
        transform: translateY(-2px);
        box-shadow: 0 6px 15px rgba(0, 255, 204, 0.2);
        border-color: #00ffcc;
    }
    div[data-testid="stMetricValue"] {
        color: #fff !important;
        font-family: 'Orbitron', sans-serif;
        text-shadow: 0 0 8px rgba(255, 255, 255, 0.5);
    }
    div[data-testid="stMetricLabel"] { color: #00ffcc !important; font-family: 'Roboto Mono', monospace; font-size: 0.9rem;}

    /* èµ›åšæœ‹å…‹æŒ‰é’® */
    .stButton>button {
        background: transparent;
        color: #00ffcc;
        font-family: 'Orbitron', sans-serif;
        font-weight: bold;
        border: 2px solid #00ffcc;
        border-radius: 5px;
        padding: 0.5rem 1rem;
        transition: all 0.3s ease;
        text-transform: uppercase;
        letter-spacing: 1px;
    }
    .stButton>button:hover {
        background-color: #00ffcc;
        color: #000;
        box-shadow: 0 0 20px #00ffcc;
    }

    /* Expander æ ·å¼ */
    .streamlit-expanderHeader {
        background-color: #111;
        color: #00ffcc;
        font-family: 'Roboto Mono', monospace;
        border: 1px solid #333;
    }

    /* ä¾§è¾¹æ ç¾åŒ– */
    section[data-testid="stSidebar"] {
        background-color: #080808;
        border-right: 1px solid #333;
    }

    /* Toast æ ·å¼ */
    .stToast {
        background-color: #111 !important;
        border: 1px solid #00ffcc !important;
        color: #fff !important;
        font-family: 'Roboto Mono', monospace;
    }
</style>
""", unsafe_allow_html=True)

# -----------------------------------------------------------------------------
# 2. çœŸå®æ•°æ®å¼•æ“ (REAL DATA ENGINE)
# -----------------------------------------------------------------------------

DEFAULT_ASSETS = {
    1: "Bitcoin", 6: "Ethereum", 2: "Bitcoin Cash", 0: "Binance Coin",
    3: "Cardano", 4: "Dogecoin", 7: "Ethereum Classic", 9: "Litecoin",
    11: "Monero", 13: "TRON", 12: "Stellar", 5: "EOS.IO", 8: "IOTA", 10: "Maker"
}

@st.cache_data
def load_dataset(train_file):
    if train_file is None:
        return None
    try:
        df = pd.read_csv(train_file)
        if 'timestamp' in df.columns:
            df['Time'] = pd.to_datetime(df['timestamp'], unit='s')

        required_cols = ['Asset_ID', 'Close', 'Open', 'High', 'Low', 'Volume']
        if not all(col in df.columns for col in required_cols):
            st.error(f"Data missing columns. Required: {required_cols}")
            return None

        df = df.drop_duplicates(subset=['Time', 'Asset_ID'], keep='last')
        return df.sort_values('Time')
    except Exception as e:
        st.error(f"File Error: {e}")
        return None

# -----------------------------------------------------------------------------
# 3. ä¾§è¾¹æ æ§åˆ¶å° (MISSION CONTROL)
# -----------------------------------------------------------------------------
st.sidebar.title("ğŸ’  QUANTUM CORE")
st.sidebar.caption("v18.0.0 [LOGIC-FIXED] | DATA INGESTION")

uploaded_file = st.sidebar.file_uploader("ğŸ“‚ UPLOAD DATA SOURCE (CSV)", type=['csv'])

if uploaded_file:
    df = load_dataset(uploaded_file)
    if df is not None:
        st.sidebar.success(f"âœ… LINK ESTABLISHED: {len(df):,} RECORDS")

        available_ids = sorted(df['Asset_ID'].unique())

        st.sidebar.markdown("---")
        st.sidebar.caption("TARGET ACQUISITION")

        asset_options = {aid: f"{DEFAULT_ASSETS.get(aid, f'Asset {aid}')} (ID:{aid})" for aid in available_ids}
        selected_id = st.sidebar.selectbox("SELECT ASSET", available_ids, format_func=lambda x: asset_options[x])
        asset_name = DEFAULT_ASSETS.get(selected_id, f"Asset {selected_id}")

        asset_df = df[df['Asset_ID'] == selected_id].copy().reset_index(drop=True)

        st.markdown(f"""
        <div class="status-bar">
            <span>TARGET: <span class="status-value">{asset_name.upper()}</span></span>
            <span>FREQ: <span class="status-value">15-MIN</span></span>
            <span>BUFFER: <span class="status-value">{len(asset_df)} BARS</span></span>
            <span>STATUS: <span class="status-value">ONLINE</span></span>
        </div>
        """, unsafe_allow_html=True)

        nav = st.sidebar.radio("NAVIGATION",
            ["1. EXECUTIVE SUMMARY",
             "2. METHODOLOGY",
             "3. MODEL SELECTION",
             "4. LIVE SIMULATION"]
        )

    else:
        st.stop()
else:
    st.title("System Initializing...")
    st.info("ğŸ‘‹ Awaiting Data Stream. Please upload 'demo.csv' or 'train.csv' to begin.")
    st.stop()

# -----------------------------------------------------------------------------
# 4. æ¨¡å—ä¸€ï¼šå•†ä¸šæ¡ˆä¾‹ (EXECUTIVE SUMMARY)
# -----------------------------------------------------------------------------
if nav == "1. EXECUTIVE SUMMARY":
    st.title(f"{asset_name} // Market Intelligence")

    st.markdown("### ğŸ¯ Strategic Objectives")
    col_biz1, col_biz2 = st.columns([1.5, 1])
    with col_biz1:
        st.info("""
        **The Challenge:**
        Cryptocurrency markets are defined by extreme **volatility** and **non-stationarity**.

        **The Solution:**
        A machine learning pipeline predicting **15-minute residualized returns** (Alpha), isolating true asset performance from market Beta using LightGBM.
        """)
    with col_biz2:
        st.metric("Forecast Horizon", "15 Minutes", "Short-Term")
        st.metric("Target Variable", "Alpha (Resid)", "Beta-Neutral")

    st.divider()

    st.markdown("### ğŸ“Š Asset Microstructure")
    last_price = asset_df['Close'].iloc[-1]
    pct_change = ((asset_df['Close'].iloc[-1] - asset_df['Close'].iloc[0]) / asset_df['Close'].iloc[0]) * 100
    total_vol = asset_df['Volume'].sum()

    m1, m2, m3, m4 = st.columns(4)
    m1.metric("Current Price", f"${last_price:,.2f}", f"{pct_change:+.2f}%")
    m2.metric("Data Points", f"{len(asset_df):,}")
    m3.metric("Asset Class", "L1/Payment")
    m4.metric("Total Volume", f"{total_vol:,.0f}")

    window = st.slider("Zoom Window (bars)", 50, 1000, 200)
    chart_df = asset_df.tail(window)

    fig = go.Figure()
    fig.add_trace(go.Candlestick(
        x=chart_df['Time'],
        open=chart_df['Open'], high=chart_df['High'],
        low=chart_df['Low'], close=chart_df['Close'],
        name='OHLC'
    ))
    fig.update_layout(template="plotly_dark", paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', height=450, xaxis_rangeslider_visible=False)
    st.plotly_chart(fig, use_container_width=True)

    if len(available_ids) > 1:
        st.divider()
        st.subheader("ğŸ”— Cross-Asset Correlation Analysis")

        default_selections = available_ids[:5] if len(available_ids) >=5 else available_ids
        selected_for_corr = st.multiselect(
            "Select Assets for Matrix",
            available_ids,
            default=default_selections,
            format_func=lambda x: asset_options[x],
            key="corr_selector"
        )

        if len(selected_for_corr) > 1:
            subset_df = df[df['Asset_ID'].isin(selected_for_corr)]
            pivot_df = subset_df.pivot(index='Time', columns='Asset_ID', values='Close')
            pivot_df.columns = [DEFAULT_ASSETS.get(c, str(c)) for c in pivot_df.columns]
            pivot_df = pivot_df.dropna()

            if not pivot_df.empty:
                corr_matrix = pivot_df.corr()
                fig_corr = px.imshow(
                    corr_matrix,
                    text_auto=True,
                    color_continuous_scale='Teal',
                    title=f"Real-Time Correlation ({len(selected_for_corr)} Assets)"
                )
                fig_corr.update_layout(template="plotly_dark", paper_bgcolor='rgba(0,0,0,0)', height=500)
                st.plotly_chart(fig_corr, use_container_width=True)

# -----------------------------------------------------------------------------
# 5. æ¨¡å—äºŒï¼šæ–¹æ³•è®º (METHODOLOGY)
# -----------------------------------------------------------------------------
elif nav == "2. METHODOLOGY":
    st.title("ğŸ›¡ï¸ Engineering Protocol")
    st.caption("Addressing Financial Time-Series Pathologies")

    col_obs, col_sol = st.columns([1, 1])
    with col_obs:
        st.subheader("âš ï¸ Detected Obstacles")
        with st.expander("1. Non-Stationarity", expanded=True):
            st.write("Prices exhibit time-varying variance. Raw price training fails ADF tests.")
        with st.expander("2. Data Leakage", expanded=True):
            st.write("Serial correlation in finance causes 'look-ahead bias' in standard CV.")
    with col_sol:
        st.subheader("âœ… Engineered Solutions")
        with st.expander("Log-Returns Transformation", expanded=True):
            st.latex(r'''r_{t,L} = \ln(P_t) - \ln(P_{t-L})''')
            st.write("Converted to stationary Log-Returns.")
        with st.expander("Purged Embargo CV", expanded=True):
            st.write("Enforced strict time-gap separation.")

    st.divider()

    st.subheader("3. Visualizing 'Embargo' Safety Mechanism")

    embargo_size = st.slider("Set Embargo Gap Size", 1, 20, 5)

    fig_cv = go.Figure()
    folds = 5
    base_train = 20
    step = 10
    test_size = 10

    for i in range(folds):
        train_len = base_train + (i * step)
        show_leg = (i == 0)

        fig_cv.add_trace(go.Bar(
            y=[f"Fold {i+1}"], x=[train_len], orientation='h',
            name='Training Data', marker=dict(color='#3b82f6'),
            legendgroup='group1', showlegend=show_leg
        ))
        fig_cv.add_trace(go.Bar(
            y=[f"Fold {i+1}"], x=[embargo_size], orientation='h',
            name='Embargo Firewall', marker=dict(color='#ef4444', pattern_shape="/"),
            legendgroup='group2', showlegend=show_leg
        ))
        fig_cv.add_trace(go.Bar(
            y=[f"Fold {i+1}"], x=[test_size], orientation='h',
            name='Future Test', marker=dict(color='#22c55e'),
            legendgroup='group3', showlegend=show_leg
        ))

    fig_cv.update_layout(
        barmode='stack', template="plotly_dark",
        xaxis_title="Timeline", yaxis_title="Folds",
        paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)',
        height=400,
        legend=dict(orientation="h", y=-0.2, x=0.5, xanchor="center")
    )
    st.plotly_chart(fig_cv, use_container_width=True)

# -----------------------------------------------------------------------------
# 6. æ¨¡å—ä¸‰ï¼šæ¨¡å‹é€‰æ‹© (MODEL SELECTION)
# -----------------------------------------------------------------------------
elif nav == "3. MODEL SELECTION":
    st.title("ğŸ† Model Evolution Architecture")

    col1, col2, col3 = st.columns(3)
    with col1:
        st.markdown("### 1. Ridge (Baseline)")
        st.error("IC: ~0.01 (Underfit)")
        st.caption("Fails to capture non-linear volatility clusters.")
    with col2:
        st.markdown("### 2. Random Forest")
        st.warning("IC: ~0.04 (Overfit)")
        st.caption("Captures non-linearity but lacks residual correction.")
    with col3:
        st.success("### 3. LightGBM (Final)")
        st.success("IC: ~0.07 (Optimal)")
        st.caption("Gradient Boosting + Optuna Hyperparameter Tuning.")

    st.divider()

    st.subheader("Performance Impact Analysis (IC Score)")
    results_data = {
        'Asset': ['Bitcoin', 'Ethereum', 'Binance Coin', 'Cardano', 'Litecoin'],
        'Ridge (Baseline)': [0.0134, 0.0480, 0.0208, 0.0471, 0.0749],
        'LightGBM (Final)': [0.0567, 0.0792, 0.0485, 0.0865, 0.0895]
    }
    df_res = pd.DataFrame(results_data)
    df_melt = df_res.melt(id_vars='Asset', var_name='Model', value_name='IC Score')

    fig_bar = px.bar(df_melt, x='Asset', y='IC Score', color='Model', barmode='group',
                     color_discrete_map={'Ridge (Baseline)': '#444', 'LightGBM (Final)': '#00ffcc'},
                     title="Model Uplift: Baseline vs Final")
    fig_bar.update_layout(template="plotly_dark", paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)', height=450)
    st.plotly_chart(fig_bar, use_container_width=True)
    st.info("ğŸš€ **Critical Finding:** Bitcoin prediction accuracy improved by **+323%** using LightGBM.")

# -----------------------------------------------------------------------------
# 7. æ¨¡å—å››ï¼šéšæœºæ¨¡æ‹Ÿ (LIVE SIMULATION)
# -----------------------------------------------------------------------------
elif nav == "4. LIVE SIMULATION":
    st.title("âš¡ Strategy Stress Test")

    c1, c2 = st.columns([1, 3])
    with c1:
        st.markdown("#### Controls")
        speed = st.select_slider("Speed", options=["Slow", "Normal", "Fast"], value="Normal")
        speed_map = {"Slow": 0.1, "Normal": 0.03, "Fast": 0.005}
        start_btn = st.button("ğŸ² INITIATE RANDOM TEST", type="primary", use_container_width=True)
    with c2:
        st.info("System randomly samples a 100-minute historical window to validate strategy robustness.")

    col_main, col_side = st.columns([2, 1])
    with col_main:
        st.subheader("Market Feed")
        chart_spot = st.empty()
    with col_side:
        st.subheader("PnL Engine")
        metric_spot = st.empty()
        pnl_spot = st.empty()

    if start_btn:
        demo_len = 100
        if len(asset_df) > demo_len + 50:
            max_start = len(asset_df) - demo_len
            start_idx = random.randint(0, max_start)
            sim_df = asset_df.iloc[start_idx : start_idx + demo_len].reset_index(drop=True)
            start_date_str = sim_df['Time'].iloc[0].strftime('%Y-%m-%d %H:%M')
            st.toast(f"â³ Time Warp: {start_date_str}", icon="ğŸš€")
        else:
            sim_df = asset_df
            start_date_str = "Start"

        prices = []
        equity = [10000]
        position = 0
        entry_price = 0

        last_equity = 10000

        for i in range(len(sim_df)):
            row = sim_df.iloc[i]
            curr_price = row['Close']
            prices.append(curr_price)

            if i > 5:
                ma_short = np.mean(prices[-5:])
                if curr_price > ma_short and position == 0:
                    position = 1
                    entry_price = curr_price
                elif curr_price < ma_short and position == 1:
                    pnl = (curr_price - entry_price) / entry_price * 10000
                    equity.append(equity[-1] + pnl)
                    position = 0
                else:
                    equity.append(equity[-1])
            else:
                equity.append(equity[-1])

            # --- è¿‡ç¨‹ç‰¹æ•ˆé€»è¾‘ (åªä¿ç•™è½»é‡çº§ Toast) ---
            curr_equity = equity[-1]
            if curr_equity > last_equity:
                profit = curr_equity - last_equity
                if profit > 20: # èµšé’±å‘ä¸ª Toast
                    st.toast(f"ğŸ’° PROFIT: +${profit:.2f}", icon="ğŸ¤‘")

            last_equity = curr_equity

            # Kçº¿å›¾
            with chart_spot.container():
                fig = go.Figure()
                curr_min = min(prices)
                curr_max = max(prices)
                r_range = max(curr_max - curr_min, curr_price * 0.001)

                # ä»…ä¿ç•™å¾®å¦™çš„èƒŒæ™¯è‰²æš—ç¤º
                bg_color = 'rgba(0,0,0,0)'
                if curr_equity < 10000:
                    bg_color = 'rgba(50, 0, 0, 0.2)'
                elif curr_equity > 10500:
                    bg_color = 'rgba(0, 50, 0, 0.2)'

                fig.add_trace(go.Scatter(y=prices, mode='lines', line=dict(color='#00ffcc', width=2)))
                fig.update_layout(
                    template="plotly_dark", height=400,
                    title=f"SCENARIO: {start_date_str} | PRICE: ${curr_price:.2f}",
                    paper_bgcolor=bg_color, plot_bgcolor=bg_color,
                    xaxis_visible=False,
                    yaxis=dict(range=[curr_min - r_range*0.1, curr_max + r_range*0.1]),
                    margin=dict(l=0,r=0,t=40,b=0)
                )
                st.plotly_chart(fig, use_container_width=True, key=f"p_{i}")

            # PnLæ›²çº¿
            with pnl_spot.container():
                fig_eq = go.Figure()
                color = '#00ff00' if equity[-1] >= 10000 else '#ff0000'
                fig_eq.add_trace(go.Scatter(y=equity, line=dict(color=color, width=2)))
                fig_eq.update_layout(
                    template="plotly_dark", height=200, title="Equity Curve",
                    paper_bgcolor='rgba(0,0,0,0)', plot_bgcolor='rgba(0,0,0,0)',
                    xaxis_visible=False, margin=dict(l=0,r=0,t=30,b=0)
                )
                st.plotly_chart(fig_eq, use_container_width=True, key=f"e_{i}")

            with metric_spot.container():
                ret = (equity[-1] - 10000) / 10000 * 100
                st.metric("Return", f"{ret:+.2f}%", f"${equity[-1]:,.2f}")
            time.sleep(0.03)

        # --- æœ€ç»ˆç»“ç®—ç‰¹æ•ˆ (Final Results FX) ---
        final_equity = equity[-1]
        if final_equity > 10000:
            st.balloons()
            st.success(f"âœ… SIMULATION COMPLETE: PROFIT SECURED (+${final_equity - 10000:.2f})")
        else:
            st.snow()
            st.error(f"ğŸ“‰ SIMULATION COMPLETE: DRAWDOWN (-${10000 - final_equity:.2f})")